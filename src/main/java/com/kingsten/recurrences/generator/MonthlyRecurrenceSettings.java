package com.kingsten.recurrences.generator;

import lombok.Data;
import lombok.NoArgsConstructor;
import lombok.ToString;

import java.time.DayOfWeek;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.YearMonth;
import java.time.format.DateTimeFormatter;


@NoArgsConstructor
@Data
@ToString
public class MonthlyRecurrenceSettings extends RecurrenceSettings {

    private int regenerateOnSpecificDateDayValue;

    private int regenEveryXMonths = 1;

    private int adjustmentValue;

    private boolean getNextDateValue;
    private LocalDateTime nextDateValue;
    private MonthlyRegenType regenType = MonthlyRegenType.NotSet;
    private MonthlySpecificDatePartOne specificDatePartOne = MonthlySpecificDatePartOne.NotSet;
    private MonthlySpecificDatePartTwo specificDatePartTwo = MonthlySpecificDatePartTwo.NotSet;

    /// <summary>
    /// Get dates by Start date only. This is for no ending date values.
    /// </summary>
    /// <param name="startDate"></param>
    public MonthlyRecurrenceSettings(LocalDateTime startDate) {
        super(startDate);
    }

    /// <summary>
    /// Get dates by Start and End date boundries.
    /// </summary>
    /// <param name="startDate"></param>
    /// <param name="endDate"></param>
    public MonthlyRecurrenceSettings(LocalDateTime startDate, LocalDateTime endDate) {
        super(startDate, endDate);
    }

    /// <summary>
    /// Get dates by Start date and number of occurrences.
    /// </summary>
    /// <param name="startDate"></param>
    /// <param name="numberOfOccurrences"></param>
    public MonthlyRecurrenceSettings(LocalDateTime startDate, int numberOfOccurrences) {
        super(startDate, numberOfOccurrences);
    }

    /// <summary>
    ///     Get a user-friendly class that is a easy way using Properties that define the Series Info
    /// </summary>
    /// <param name="seriesInfo" type="string">
    ///     <para>
    ///         String of Series Info that was first generated by this MonthlyRecurrenceSettings Class object.
    ///     </para>
    /// </param>
    /// <returns>
    ///     A RecurrenceGenerator.RecurrenceInfo value...
    /// </returns>
    static RecurrenceInfo getFriendlyRecurrenceInfo(String seriesInfo) {
        RecurrenceInfo info = new RecurrenceInfo();
        EndDateType endType = EndDateType.NotDefined;
        LocalDateTime endDateValue = LocalDateTime.MIN;
        int noOccurrences;

        // Exit if not a Monthly seriesInfo type
        if (!seriesInfo.startsWith("M")) return null;

        info.setSeriesInfo(seriesInfo);
        info.setRecurrenceType(RecurrenceInfo.RecurrenceType.Monthly);
        // FORMATTING DEFINITIONS
        //  Y = Yearly Designator
        //  |       0 = Start Date (8 chars)
        //  |       |        1 = End Date (8 chars)
        //  |       |        |        2 = Number of occurrences (4 chars)
        //  |       |        |        |      3 = Regeneration Type (1 char)
        //  |       |        |        |      |    4 = End date type (1 char)
        //  |       |        |        |      |    |      5 = Regenerate on specific date DAY value (2 chars)
        //  |       |        |        |      |    |      |       6 = Custom Date Part One (1 char)
        //  |       |        |        |      |    |      |       |       7 = Custom Date Part Two (1 char)
        //  |       |        |        |      |    |      |       |       |       8 = Adjustment Value (3 chars)
        //  |       |        |        |      |    |      |       |       |       |     9  Regen Every x months
        //  |       |        |        |      |    |      |       |       |       |     |
        // [0]    [1-8]    [9-16]  [17-20]  [21] [22] [23-24]  [25]    [26]    [27-29] [30-32]
        //  M   01082007  20171231   0000    1     1     00      A      A       000    000
        String startDate = seriesInfo.substring(1, 9);

        LocalDate date = LocalDate.parse(startDate, DateTimeFormatter.BASIC_ISO_DATE);
        LocalDateTime dtStartDate = date.atStartOfDay();
        String endDate = seriesInfo.substring(9, 17);

        String occurrences = seriesInfo.substring(17, 21);
        String monthlyRegenType = seriesInfo.substring(21, 22);
        String endDateType = seriesInfo.substring(22, 23);
        String regenOnSpecificDateDayValue = seriesInfo.substring(23, 25);
        String specDatePartOne = seriesInfo.substring(25, 26);
        String specDatePartTwo = seriesInfo.substring(26, 27);
        String adjustValue = seriesInfo.substring(27, 30);
        int regenXMonths = Integer.valueOf(seriesInfo.substring(30, 33));
        endType = EndDateType.fromValue(endDateType);
        noOccurrences = Integer.valueOf(occurrences);

        MonthlySpecificDatePartOne partOne = MonthlySpecificDatePartOne.NotSet;
        MonthlySpecificDatePartTwo partTwo = MonthlySpecificDatePartTwo.NotSet;

        if (specDatePartOne == "Z") partOne = MonthlySpecificDatePartOne.NotSet;
        else partOne = MonthlySpecificDatePartOne.fromValue(specDatePartOne.charAt(0) - 65);

        if (specDatePartTwo == "Z") partTwo = MonthlySpecificDatePartTwo.NotSet;
        else partTwo = MonthlySpecificDatePartTwo.fromValue(specDatePartTwo.charAt(0) - 65);

        // Get the EndDate before any modifications on it are performed
        if (endType == EndDateType.SpecificDate) {
            date = LocalDate.parse(endDate, DateTimeFormatter.BASIC_ISO_DATE);
            endDateValue = date.atStartOfDay();
        }

        info.setEndDateType(endType);
        // Determine the Constructor by the type of End Date.
        // All constructors start with a Start date at a minimum.
        switch (endType) {
            case NumberOfOccurrences:
                info.setStartDate(dtStartDate);
                info.setNumberOfOccurrences(noOccurrences);
                break;

            case SpecificDate:
                info.setStartDate(dtStartDate);
                info.setEndDate(endDateValue);
                break;

            case NoEndDate:
                info.setStartDate(dtStartDate);
                break;
        }

        // Set the adjusted values
        info.setAdjustmentValue(Integer.valueOf(adjustValue));
        info.setMonthlyRegenType(MonthlyRegenType.fromValue(Integer.valueOf(monthlyRegenType)));

        // Determine the Type of dates to get, specific, custom, etc.
        switch (info.monthlyRegenType) {
            case OnSpecificDayOfMonth:
                info.setMonthlyRegenerateOnSpecificDateDayValue(Integer.valueOf(regenOnSpecificDateDayValue));
                info.setRegenEveryXMonths(regenXMonths);
                break;

            case OnCustomDateFormat:
                info.setMonthlySpecificDatePartOne(partOne);
                info.setMonthlySpecificDatePartTwo(partTwo);
                info.setRegenEveryXMonths(regenXMonths);
                break;

            case AfterOccurrenceCompleted:

                break;
        }

        return info;
    }

    //#region  Procedures
    static String getPatternDefinition(String seriesInfo) {
        String returnValue = "";
        returnValue =
                " MONTHLY FORMATTING DEFINITIONS\r\n" +
                        "  M = Monthly Designator\r\n" +
                        "  |       0 = Start Date (8 chars)\r\n" +
                        "  |       |        1 = End Date (8 chars)\r\n" +
                        "  |       |        |        2 = Number of occurrences (4 chars)\r\n" +
                        "  |       |        |        |      3 = Regeneration Type (1 char)\r\n" +
                        "  |       |        |        |      |    4 = End date type (1 char)\r\n" +
                        "  |       |        |        |      |    |      5 = Regenerate on specific date DAY value (2 chars)\r\n" +
                        "  |       |        |        |      |    |      |       6 = Custom Date Part One (1 char)\r\n" +
                        "  |       |        |        |      |    |      |       |       7 = Custom Date Part Two (1 char)\r\n" +
                        "  |       |        |        |      |    |      |       |       |        8 = Adjustment Value (3 chars)\r\n" +
                        "  |       |        |        |      |    |      |       |       |        |       9  Regen Every x months\r\n" +
                        "  |       |        |        |      |    |      |       |       |        |       |  \r\n" +
                        " [0]    [1-8]    [9-16]  [17-20]  [21] [22] [23-24]  [25]    [26]    [27-29] [30-32]\r\n" +
                        String.format("  M    %s %s  %s     %s    %s     %s      %s       %s        %s     %s\r\n",
                                seriesInfo.substring(1, 9), seriesInfo.substring(9, 17), seriesInfo.substring(17, 21), seriesInfo.substring(21, 22), seriesInfo.substring(22, 23),
                                seriesInfo.substring(23, 25), seriesInfo.substring(25, 26), seriesInfo.substring(26, 27), seriesInfo.substring(27, 30), seriesInfo.substring(30, 33));

        return returnValue;
    }

    static MonthlyRecurrenceSettings getRecurrenceSettings(String seriesInfo) {
        return getRecurrenceSettings(seriesInfo, -1, LocalDateTime.MIN);
    }

    static MonthlyRecurrenceSettings getRecurrenceSettings(LocalDateTime modifiedStartDate, String seriesInfo) {
        return getRecurrenceSettings(seriesInfo, -1, modifiedStartDate, LocalDateTime.MIN);
    }

    static MonthlyRecurrenceSettings getRecurrenceSettings(String seriesInfo, int modifiedOccurrencesValue) {
        return getRecurrenceSettings(seriesInfo, modifiedOccurrencesValue, LocalDateTime.MIN);
    }

    static MonthlyRecurrenceSettings getRecurrenceSettings(String seriesInfo, LocalDateTime modifiedStartDate, int modifiedOccurrencesValue) {
        return getRecurrenceSettings(seriesInfo, modifiedOccurrencesValue, modifiedStartDate, LocalDateTime.MIN);
    }

    static MonthlyRecurrenceSettings getRecurrenceSettings(String seriesInfo, LocalDateTime modifiedEndDate) {
        return getRecurrenceSettings(seriesInfo, -1, modifiedEndDate);
    }

    static MonthlyRecurrenceSettings getRecurrenceSettings(String seriesInfo, LocalDateTime modifiedStartDate, LocalDateTime modifiedEndDate) {
        return getRecurrenceSettings(seriesInfo, -1, modifiedStartDate, modifiedEndDate);
    }

    static MonthlyRecurrenceSettings getRecurrenceSettings(String seriesInfo, int modifiedOccurrencesValue, LocalDateTime modifiedStartDate, LocalDateTime modifiedEndDate) {
        // Get the Recurrence Info object. This makes it easy to work with existing series of date patterns.
        RecurrenceInfo info = MonthlyRecurrenceSettings.getFriendlyRecurrenceInfo(seriesInfo);
        MonthlyRecurrenceSettings settings = null;

        // Check to see if this is to modify the SeriesInfo and run as endtype for occurrences
        if (modifiedOccurrencesValue != -1) {
            info.setEndDateType(EndDateType.NumberOfOccurrences);
            info.setNumberOfOccurrences(modifiedOccurrencesValue);
        }
        // Check to see if this is to modify the EndDate and run as endType for EndDate
        if (modifiedEndDate != LocalDateTime.MIN) {
            info.setEndDateType(EndDateType.SpecificDate);
            info.setEndDate(modifiedEndDate);
        }

        // Determine the Constructor by the type of End Date.
        // All constructors start with a Start date at a minimum.
        switch (info.endDateType) {
            case NumberOfOccurrences:
                settings = new MonthlyRecurrenceSettings(modifiedStartDate, info.numberOfOccurrences);
                break;

            case SpecificDate:
                settings = new MonthlyRecurrenceSettings(modifiedStartDate, info.endDate);
                break;

            case NoEndDate:
                settings = new MonthlyRecurrenceSettings(modifiedStartDate);
                break;
        }

        settings.adjustmentValue = info.adjustmentValue;

        // Determine the Type of dates to get, specific, custom, etc.
        switch (info.monthlyRegenType) {
            case OnSpecificDayOfMonth:
                settings.setValues(info.monthlyRegenerateOnSpecificDateDayValue, info.regenEveryXMonths);
                break;

            case OnCustomDateFormat:
                settings.setValues(info.monthlySpecificDatePartOne, info.monthlySpecificDatePartTwo, info.regenEveryXMonths);
                break;

            case AfterOccurrenceCompleted:

                break;
        }

        return settings;
    }
    //#endregion //Private Procedures

    static MonthlyRecurrenceSettings getRecurrenceSettings(String seriesInfo, int modifiedOccurrencesValue, LocalDateTime modifiedEndDate) {
        // Get the Recurrence Info object. This makes it easy to work with existing series of date patterns.
        RecurrenceInfo info = MonthlyRecurrenceSettings.getFriendlyRecurrenceInfo(seriesInfo);
        return getRecurrenceSettings(seriesInfo, modifiedOccurrencesValue, info.startDate, modifiedEndDate);
    }

    /// <summary>
    /// Get the Series information that's used to get dates at a later
    /// date. This is passed into the RecurrenceHelper to get date values.
    /// Most likely used for non-ending dates.
    /// </summary>
    /// <returns></returns>
    String getSeriesInfo() {
        String info;
        String endDate = "ZZZZZZZZ"; // Default for no ending date.
        String occurrences = String.format("%04d", this.numberOfOccurrences);
        String monthlyRegenType = this.regenType.toString();
        String endDateType = this.endDateType.toString();
        String regenOnSpecificDateDayValue = String.format("%02d", this.regenerateOnSpecificDateDayValue);
        String specDatePartOne = "Z";
        String specDatePartTwo = "Z";
        String regenXMonths = String.format("%03d", this.regenEveryXMonths);

        if (specificDatePartOne != MonthlySpecificDatePartOne.NotSet) specDatePartOne = specificDatePartOne.toString();

        if (specificDatePartTwo != MonthlySpecificDatePartTwo.NotSet) specDatePartTwo = specificDatePartTwo.toString();

        String adjustValue = String.format("%03d", this.adjustmentValue);

        // If the Adjustment value is less than Zero then account for the "-"
        if (adjustmentValue < 0) adjustValue = String.format("%02d", this.adjustmentValue);

        // End Date may be null if no ending date.
        if (this.hasEndDate()) endDate = DateTimeFormatter.BASIC_ISO_DATE.format(this.endDate);

        // FORMATTING DEFINITIONS
        //  Y = Monthly Designator
        //  |       0 = Start Date (8 chars)
        //  |       |        1 = End Date (8 chars)
        //  |       |        |        2 = Number of occurrences (4 chars)
        //  |       |        |        |      3 = Regeneration Type (1 char)
        //  |       |        |        |      |    4 = End date type (1 char)
        //  |       |        |        |      |    |      5 = Regenerate on specific date DAY value (2 chars)
        //  |       |        |        |      |    |      |       6 = Custom Date Part One (1 char)
        //  |       |        |        |      |    |      |       |       7 = Custom Date Part Two (1 char)
        //  |       |        |        |      |    |      |       |       |       8 = Adjustment Value (3 chars)
        //  |       |        |        |      |    |      |       |       |       |     9  Regen Every x months
        //  |       |        |        |      |    |      |       |       |       |     |
        // [0]    [1-8]    [9-16]  [17-20]  [21] [22] [23-24]  [25]    [26]    [27-29] [30-32]
        //  M   20071231  20171231   0000    1     1     00      A      A       000    000
        info = String.format("M%s%s%s%s%s%s%s%s%s%s", DateTimeFormatter.BASIC_ISO_DATE.format(this.startDate), endDate, occurrences, monthlyRegenType, endDateType, regenOnSpecificDateDayValue, specDatePartOne, specDatePartTwo, adjustValue, regenXMonths);
        return info;
    }

    /// <summary>
    /// Get recurring dates from a specific constant date such as 27 July.
    /// </summary>
    /// <returns></returns>
    RecurrenceValues getSpecificDayOfMonthDates() throws Exception {
        RecurrenceValues values = new RecurrenceValues();
        LocalDateTime dt = this.startDate;
        int dayValue = regenerateOnSpecificDateDayValue;
        int daysOfMonth = YearMonth.of(dt.getYear(), dt.getMonth()).lengthOfMonth();
        // Get the max days of the month and make sure it's not
        // less than the specified day value trying to be set.
        if (daysOfMonth < regenerateOnSpecificDateDayValue) dayValue = daysOfMonth;

        // Determine if start date is greater than the Day and Month values
        // for a specific date.
        LocalDateTime newDate = LocalDateTime.of(dt.getYear(), dt.getMonth(), dayValue, 0, 0);
        // Is the specific date before the start date, if so
        // then make the specific date next month.
        if (newDate.compareTo(dt) < 0) dt = newDate.plusMonths(1);
        else dt = newDate;


        if (getNextDateValue) {
            do {
                values.AddDateValue(dt, adjustmentValue);
                if (values.values.get(values.values.size() - 1).compareTo(nextDateValue) > 0) break;

                dt = dt.plusMonths(regenEveryXMonths);
                dt = getCorrectedDate(dt);
            } while (dt.compareTo(nextDateValue.plusMonths(regenEveryXMonths + 1)) <= 0); // Ensure the last date if greater than what's needed for the next date in the cycle
        } else {
            switch (this.endDateType) {
                case NoEndDate:
                    throw new Exception("The ability to create recurring dates with no End date is not currently available.");

                case NumberOfOccurrences:

                    for (int i = 0; i < this.numberOfOccurrences; i++) {
                        values.AddDateValue(dt, adjustmentValue);
                        dt = dt.plusMonths(regenEveryXMonths);
                        dt = getCorrectedDate(dt);
                    }
                    break;

                case SpecificDate:
                    do {
                        values.AddDateValue(dt, adjustmentValue);
                        dt = dt.plusMonths(regenEveryXMonths);
                        dt = getCorrectedDate(dt);
                    } while (dt.compareTo(this.endDate) <= 0);
                    break;

                default:
                    throw new IllegalArgumentException("The TypeOfEndDate property has not been set.");
            }
        }

        return values;
    }
//#endregion //Public GetValues

    //#endregion //Public Fields

    /// <summary>
    /// Correct an input date to be equal to or less than the specified day value.
    /// </summary>
    /// <param name="input">Date to check to ensure it matches the specified day value or the max number of days for that month, whichever comes first.</param>
    /// <returns>DateTime</returns>
    LocalDateTime getCorrectedDate(LocalDateTime input) {
        LocalDateTime dt = input;
        // Ensure the day value hasn't changed.
        // This will occurr if the month is Feb. All
        // dates after that will have the same day.
        if (dt.getDayOfMonth() < this.regenerateOnSpecificDateDayValue && YearMonth.of(dt.getYear(), dt.getMonth()).lengthOfMonth() > dt.getDayOfMonth()) {
            // The Specified day is greater than the number of days in the month.
            if (this.regenerateOnSpecificDateDayValue > YearMonth.of(dt.getYear(), dt.getMonth()).lengthOfMonth())
                dt = LocalDateTime.of(dt.getYear(), dt.getMonth(), YearMonth.of(dt.getYear(), dt.getMonth()).lengthOfMonth(), 0, 0);
            else
                // The specified date is less than number of days in month.
                dt = LocalDateTime.of(dt.getYear(), dt.getMonth(), this.regenerateOnSpecificDateDayValue, 0, 0);
        }
        return dt;
    }

    /// <summary>
    /// Get recurring dates from custom date such as First Sunday of July.
    /// </summary>
    /// <returns></returns>
    RecurrenceValues getCustomDayOfMonthDates() throws Exception {
        if (this.specificDatePartOne == MonthlySpecificDatePartOne.NotSet)
            throw new Exception("The First part of the custom date has not been set.");
        if (this.specificDatePartTwo == MonthlySpecificDatePartTwo.NotSet)
            throw new Exception("The Second part of the custom date has not been set.");

        RecurrenceValues values = new RecurrenceValues();
        LocalDateTime dt = this.startDate;

        // Get Next Date value only
        if (getNextDateValue) {
            do {
                dt = getCustomDate(dt);
                // If the date returned is less than the start date
                // then do it again to increment past the start date
                if (dt.compareTo(this.startDate) < 0) {
                    dt = dt.plusMonths(1);
                    dt = getCustomDate(dt);
                }
                values.AddDateValue(dt, adjustmentValue);
                if (values.values.get(values.values.size() - 1).compareTo(nextDateValue) > 0) break;

                dt = dt.plusMonths(regenEveryXMonths);

            } while (dt.compareTo(nextDateValue.plusMonths(regenEveryXMonths + 1)) <= 0); // Ensure the last date if greater than what's needed for the next date in the cycle
        } else {
            switch (this.endDateType) {
                case NoEndDate:
                    throw new Exception("The ability to create recurring dates with no End date is not currently available.");

                case NumberOfOccurrences:
                    for (int i = 0; i < this.numberOfOccurrences; i++) {
                        dt = getCustomDate(dt);
                        // If the date returned is less than the start date
                        // then do it again to increment past the start date
                        if (dt.compareTo(this.startDate) < 0) {
                            dt = dt.plusMonths(1);
                            dt = getCustomDate(dt);
                        }
                        values.AddDateValue(dt, adjustmentValue);
                        dt = dt.plusMonths(regenEveryXMonths);
                    }
                    break;

                case SpecificDate:
                    do {
                        dt = getCustomDate(dt);
                        // If the date returned is less than the start date
                        // then do it again to increment past the start date
                        if (dt.compareTo(this.startDate) < 0) {
                            dt = dt.plusMonths(1);
                            dt = getCustomDate(dt);
                        }
                        values.AddDateValue(dt, adjustmentValue);
                        dt = dt.plusMonths(regenEveryXMonths);
                    } while (dt.compareTo(this.endDate) <= 0);
                    break;

                default:
                    throw new IllegalArgumentException("The TypeOfEndDate property has not been set.");
            }
        }
        return values;

    }

    /// <summary>
    /// Get the custom value from the 1st, 2nd, and 3rd custom date parts
    /// </summary>
    /// <param name="year"></param>
    /// <returns></returns>
    LocalDateTime getCustomDate(LocalDateTime currentDate) {
        int year = currentDate.getYear();
        LocalDateTime dt = LocalDateTime.of(year, currentDate.getMonth(), 1, 0, 0);
        int day = 1;
        int firstPart = specificDatePartOne.getValue() + 1;
        int daysOfMonth = YearMonth.of(year, dt.getMonth()).lengthOfMonth();

        switch (specificDatePartTwo) {
            case Day:
                // If only getting the Last day of the month
                if (specificDatePartOne == MonthlySpecificDatePartOne.Last)
                    dt = LocalDateTime.of(year, dt.getMonth(), YearMonth.of(year, dt.getMonth()).lengthOfMonth(), 0, 0);
                else
                    // Get a specific day of the month such as First, Second, Third, Fourth
                    dt = LocalDateTime.of(year, dt.getMonth(), firstPart, 0, 0);

                break;

            case Weekday:
                int weekDayCount = 0;
                LocalDateTime lastWeekday = dt;
                do {
                    // Check for anything other than Saturday and Sunday
                    if (dt.getDayOfWeek() != DayOfWeek.SATURDAY && dt.getDayOfWeek() != DayOfWeek.SUNDAY) {
                        // Get a specific Weekday of the Month
                        if (specificDatePartOne != MonthlySpecificDatePartOne.Last) {
                            // Add up the weekday count
                            weekDayCount++;
                            // If the current weekday count matches then exit
                            if (weekDayCount == firstPart) break;
                        } else {
                            // Get the last weekday of the month
                            lastWeekday = dt;
                        }
                    }
                    dt = dt.plusDays(1);
                    day++;
                } while (day <= daysOfMonth);

                // If getting the last weekday of the month then
                // set the returning value to the last weekday found.
                if (specificDatePartOne == MonthlySpecificDatePartOne.Last) dt = lastWeekday;

                break;

            case WeekendDay:
                int weekendDayCount = 0;
                LocalDateTime lastWeekendday = dt;
                do {
                    // Check for anything other than Saturday and Sunday
                    if (dt.getDayOfWeek() == DayOfWeek.SATURDAY || dt.getDayOfWeek() == DayOfWeek.SUNDAY) {
                        // Get a specific Weekday of the Month
                        if (specificDatePartOne != MonthlySpecificDatePartOne.Last) {
                            // Add up the weekday count
                            weekendDayCount++;
                            // If the current weekday count matches then exit
                            if (weekendDayCount == firstPart) break;
                        } else {
                            // Get the last weekday of the month
                            lastWeekendday = dt;
                        }
                    }
                    dt = dt.plusDays(1);
                    day++;
                } while (day <= daysOfMonth);

                // If getting the last weekday of the month then
                // set the returning value to the last weekday found.
                if (specificDatePartOne == MonthlySpecificDatePartOne.Last) dt = lastWeekendday;

                break;

            case Monday:
                dt = getCustomWeekday(dt, DayOfWeek.MONDAY, daysOfMonth, firstPart);
                break;

            case Tuesday:
                dt = getCustomWeekday(dt, DayOfWeek.TUESDAY, daysOfMonth, firstPart);
                break;

            case Wednesday:
                dt = getCustomWeekday(dt, DayOfWeek.WEDNESDAY, daysOfMonth, firstPart);
                break;

            case Thursday:
                dt = getCustomWeekday(dt, DayOfWeek.THURSDAY, daysOfMonth, firstPart);
                break;

            case Friday:
                dt = getCustomWeekday(dt, DayOfWeek.FRIDAY, daysOfMonth, firstPart);
                break;

            case Saturday:
                dt = getCustomWeekday(dt, DayOfWeek.SATURDAY, daysOfMonth, firstPart);
                break;

            case Sunday:
                dt = getCustomWeekday(dt, DayOfWeek.SUNDAY, daysOfMonth, firstPart);
                break;
        }
        return dt;
    }

    LocalDateTime getCustomWeekday(LocalDateTime startDate, DayOfWeek weekDay, int daysOfMonth, int firstDatePart) {
        int day = 1;
        int dayCount = 0;
        LocalDateTime lastDOW = startDate;
        LocalDateTime returnDate = startDate;
        do {
            // Check for day of the week
            if (returnDate.getDayOfWeek() == weekDay) {
                // Get a specific Weekday of the Month
                if (specificDatePartOne != MonthlySpecificDatePartOne.Last) {
                    // Add up the days found count
                    dayCount++;
                    // If the current weekday count matches then exit
                    if (dayCount == firstDatePart) {
                        break;
                    }
                } else {
                    // Get the current date value
                    lastDOW = returnDate;
                }
            }
            returnDate = returnDate.plusDays(1);
            day++;
        } while (day <= daysOfMonth);

        // If getting the last weekday of the month then
        // set the returning value to the last weekday found.
        if (specificDatePartOne == MonthlySpecificDatePartOne.Last) returnDate = lastDOW;

        return returnDate;
    }

    //#region Public GetValues
    /// <summary>
    /// Get Custom dates such as Last Saturday of the month with option as to the increment of every x-months.
    /// </summary>
    /// <param name="customDatePartOne">Corresponds to Part of month such as First, Last.</param>
    /// <param name="customDatePartTwo">Corresponds to day of the week to get such as Tuesday or Weekend Day.</param>
    /// <param name="regenEveryXMonths">How many months to skip, such as 2 for every other month.</param>
    /// <returns></returns>
    public RecurrenceValues getValues(MonthlySpecificDatePartOne customDatePartOne, MonthlySpecificDatePartTwo customDatePartTwo, int regenEveryXMonths) throws Exception {
        this.regenEveryXMonths = regenEveryXMonths;
        this.specificDatePartOne = customDatePartOne;
        this.specificDatePartTwo = customDatePartTwo;
        this.regenType = MonthlyRegenType.OnCustomDateFormat;
        return getValues();
    }

    /// <summary>
    /// Get values for a specific day of the month. Eg. Every 23rd day. With option to get every x-month.
    /// </summary>
    /// <param name="dayOfMonthToRegen">Day of month you want to set as the value to get from month to month.</param>
    /// <param name="regenEveryXMonths">How many months to skip, such as 2 for every other month.</param>
    /// <returns></returns>
    public RecurrenceValues getValues(int dayOfMonthToRegen, int regenEveryXMonths) throws Exception {
        this.regenEveryXMonths = regenEveryXMonths;
        regenerateOnSpecificDateDayValue = dayOfMonthToRegen;
        regenType = MonthlyRegenType.OnSpecificDayOfMonth;
        return getValues();
    }

    //#region  GetValues
    /// <summary>
    ///      Final overloaded function that gets the Recurrence Values.
    ///      This is called from the RecurrenceHelper staic methods only.
    /// </summary>
    /// <returns>
    ///     A RecurrenceGenerator.RecurrenceValues value...
    /// </returns>
    RecurrenceValues getValues() throws Exception {
        return getRecurrenceValues();
    }

    RecurrenceValues getValues(LocalDateTime startDate, LocalDateTime endDate) throws Exception {
        this.startDate = startDate;
        this.endDate = endDate;
        // Change the end type to End Date as this original series info
        // may have been set to number of occurrences.
        this.endDateType = EndDateType.SpecificDate;
        return getRecurrenceValues();
    }

    RecurrenceValues getValues(LocalDateTime startDate, int numberOfOccurrences) throws Exception {
        this.numberOfOccurrences = numberOfOccurrences;
        this.startDate = startDate;
        // Change the end type to number of occurrences.
        // This must be set because the original starting Series Info may
        // be set to have an End Date type.
        this.endDateType = EndDateType.NumberOfOccurrences;
        return getRecurrenceValues();
    }

    RecurrenceValues getRecurrenceValues() throws Exception {
        RecurrenceValues values = null;
        switch (regenType) {
            case OnSpecificDayOfMonth:
                values = getSpecificDayOfMonthDates();
                break;

            case OnCustomDateFormat:
                values = getCustomDayOfMonthDates();
                break;

            case AfterOccurrenceCompleted:

                break;

        }
        if (values.values.size() > 0) {
            values.setStartDate(values.values.get(0));

            // Get the end date if not open-ended
            if (this.endDateType != EndDateType.NoEndDate)
                values.setEndDate(values.values.get(values.values.size() - 1));
        }

        // Set the Series information that's used to get the next date
        // values for no ending dates.
        values.setSeriesInfo(getSeriesInfo());

        return values;
    }

    void setValues(MonthlySpecificDatePartOne customDatePartOne, MonthlySpecificDatePartTwo customDatePartTwo, int regenEveryXMonths) {
        this.regenEveryXMonths = regenEveryXMonths;
        specificDatePartOne = customDatePartOne;
        specificDatePartTwo = customDatePartTwo;
        regenType = MonthlyRegenType.OnCustomDateFormat;
    }

    void setValues(int dayOfMonthToRegen, int regenEveryXMonths) {
        this.regenEveryXMonths = regenEveryXMonths;
        regenerateOnSpecificDateDayValue = dayOfMonthToRegen;
        regenType = MonthlyRegenType.OnSpecificDayOfMonth;
    }

    LocalDateTime getNextDate(LocalDateTime currentDate) throws Exception {
        getNextDateValue = true;
        nextDateValue = currentDate;
        // Now get the values and return the last date found.
        RecurrenceValues values = getValues();
        return values.endDate;
    }

    /// <summary>
    /// The Regeneration type. Is this on a specific day of the month, a custom date, or after the occurrence is completed.
    /// </summary>
    public enum MonthlyRegenType {
        NotSet(-1), OnSpecificDayOfMonth(0), OnCustomDateFormat(1), AfterOccurrenceCompleted(2);
        int intVal;

        MonthlyRegenType(int s) {
            intVal = s;
        }

        public static MonthlyRegenType fromValue(int intVal) {
            for (MonthlyRegenType e : MonthlyRegenType.values()) {
                if (e.intVal == intVal) {
                    return e;
                }
            }
            return null;
        }

        public String toString() {
            return String.valueOf(intVal);
        }
    }

    /// <summary>
    /// First part of a custom date. This would be First, Second, etc. item of the month.
    /// </summary>
    public enum MonthlySpecificDatePartOne {
        NotSet(-1), First(0), Second(1), Third(2), Fourth(3), Last(4);
        int intVal;

        MonthlySpecificDatePartOne(int s) {
            intVal = s;
        }

        public static MonthlySpecificDatePartOne fromValue(int intVal) {
            for (MonthlySpecificDatePartOne e : MonthlySpecificDatePartOne.values()) {
                if (e.intVal == intVal) {
                    return e;
                }
            }
            return null;
        }

        public String toString() {
            return Character.toString((char) (intVal + 65));
        }

        public int getValue() {
            return intVal;
        }
    }

    /// <summary>
    /// Second part of a custom date. This is day of week, weekend day, etc.
    /// </summary>
    public enum MonthlySpecificDatePartTwo {
        NotSet(-1), Day(1), Weekday(2), WeekendDay(3), Sunday(4), Monday(5), Tuesday(6), Wednesday(7), Thursday(8), Friday(9), Saturday(10);

        int intVal;

        MonthlySpecificDatePartTwo(int s) {
            intVal = s;
        }

        public static MonthlySpecificDatePartTwo fromValue(int intVal) {
            for (MonthlySpecificDatePartTwo e : MonthlySpecificDatePartTwo.values()) {
                if (e.intVal == intVal) {
                    return e;
                }
            }
            return null;
        }

        public String toString() {
            return Character.toString((char) (intVal + 65));
        }
    }
    //#endregion // Procedures


}
